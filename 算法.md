# Java实现队列和栈



## 队列（Queue）

（先进先出，一端进一端出）

### 继承关系

![队列继承关系](https://images2017.cnblogs.com/blog/1182892/201711/1182892-20171122100317930-842768608.png)

### 概念

在并发编程中，有时候需要使用线程安全的队列。如果要实现一个线程安全的队列通常有两种方式：一种是使用阻塞队列，另一种是使用线程同步锁。

**阻塞队列**：假设有一个面包房，里面有一个客人吃面包，一个师傅烤面包。篮子里面最多放2个面包，师傅考完了面包放到篮子里，而客人吃面包则从篮子里面往外拿，为了保证客人吃面包的时候篮子里有面包或者师傅烤面包的时候篮子不会溢出，这时候就需要引用出来阻塞队列的概念，就是我们常说的生产者消费者的模式。

​	阻塞队列是一个支持两个附加操作的队列。这两个附加的操作支持阻塞的插入和移除方法。

1）支持阻塞的插入方法：意思是当队列满时，队列会阻塞插入元素的线程，直到队列不满。

2）支持阻塞的移除方法：意思是在队列为空时，获取元素的线程会等待队列变为非空。阻塞队列常用于生产者和消费者的场景，生产者是向队列里添加元素的线程，消费者是从队列里取元素的线程。阻塞队列就是生产者用来存放元素、消费者用来获取元素的容器。



阻塞队列：java.util.concurrent 中加入了 BlockingQueue 接口和五个阻塞队列类。它实质上就是一种带有一点扭曲的 FIFO 数据结构。不是立即从队列中添加或者删除元素，线程执行操作阻塞，直到有空间或者元素可用。

> ArrayBlockingQueue ：一个由数组支持的有界队列。
>
> LinkedBlockingQueue ：一个由链接节点支持的可选有界队列。
>
> PriorityBlockingQueue ：一个由优先级堆支持的无界优先级队列。
>
> DelayQueue ：一个由优先级堆支持的、基于时间的调度队列。
>
> SynchronousQueue ：一个利用 BlockingQueue 接口的简单聚集（rendezvous）机制。

> 前三个区别：他们也是继承自AbstractQueue，实现了Serializable接口；不同的是他们同时实现了BlockingQueue接口。
>
> **LinkedBlockingQueue**LinkedBlockingQueue默认大小是Integer.MAX_VALUE，可以理解为一个缓存的有界等待队列，可以选择指定其最大容量，它是基于链表的队列，此队列按 FIFO（先进先出）排序元素。当生产者往队列中放入一个数据时，缓存在队列内部，当队列缓冲区达到最大值缓存容量时（LinkedBlockingQueue可以通过构造函数指定该值），阻塞生产者队列，直到消费者从队列中消费掉一份数据，生产者线程会被唤醒，反之对于消费者同理。
>
> **ArrayBlockingQueue**在构造时需要指定容量， 并可以选择是否需要公平性，如果公平参数被设置true，等待时间最长的线程会优先得到处理（其实就是通过将ReentrantLock设置为true来 达到这种公平性的：即等待时间最长的线程会先操作）。通常，公平性会使你在性能上付出代价，只有在的确非常需要的时候再使用它。它是基于数组的阻塞循环队列，此队列按FIFO（先进先出）原则对元素进行排序。
>
> **PriorityBlockingQueue**是一个带优先级的 队列，而不是先进先出队列。元素按优先级顺序被移除，该队列也没有上限（看了一下源码，PriorityBlockingQueue是对 PriorityQueue的再次包装，是基于堆数据结构的，而PriorityQueue是没有容量限制的，与ArrayList一样，所以在优先阻塞 队列上put时是不会受阻的。虽然此队列逻辑上是无界的，但是由于资源被耗尽，所以试图执行添加操作可能会导致 OutOfMemoryError），但是如果队列为空，那么取元素的操作take就会阻塞，所以它的检索操作take是受阻的。另外，往入该队列中的元 素要具有比较能力。

> **关于ConcurrentLinkedQueue和LinkedBlockingQueue：**
>
> 也可以理解为阻塞队列和非阻塞队列的区别：
>
> 1.LinkedBlockingQueue是使用锁机制，ConcurrentLinkedQueue是使用CAS算法，虽然LinkedBlockingQueue的底层获取锁也是使用的CAS算法
>
> 2.关于取元素，ConcurrentLinkedQueue不支持阻塞去取元素，LinkedBlockingQueue支持阻塞的take()方法。
>
> 3.关于插入元素的性能，但在实际的使用过程中，尤其在多cpu的服务器上，有锁和无锁的差距便体现出来了，ConcurrentLinkedQueue会比LinkedBlockingQueue快很多。



不阻塞队列：PriorityQueue 和 ConcurrentLinkedQueue

> ​	PriorityQueue 类继承自AbstractQueue，实现了Serializable接口。实质上维护了一个有序列表，PriorityQueue位于Java util包中，观其名字前半部分的单词*Priority*是优先的意思，实际上这个队列就是具有“优先级”。加入到 Queue 中的元素根据它们的天然排序（通过其 java.util.Comparable 实现）或者根据传递给构造函数的 java.util.Comparator 实现来定位。
> 　ConcurrentLinkedQueue 是基于链接节点的、线程安全的队列。并发访问不需要同步。因为它在队列的尾部添加元素并从头部删除它们，所以不需要知道队列的大小， ConcurrentLinkedQueue 对公共集合的共享访问就可以工作得很好。收集关于队列大小的信息会很慢，需要遍历队列；ConcurrentLinkedQueue是一个基于链接节点的无界线程安全队列，它采用先进先出的规则对节点进行排序，当我们添加一个元素的时候，它会添加到队列的尾部；当我们获取一个元素时，它会返回队列头部的元素。



### 常用方法

构造方法

```java
Queue<Integer> queue = new ConcurrentLinkedDeque<>();
Queue<Integer> queue2 = new LinkedList<>();
```

使用方法

> **获取头元素的方法**
>
> **1.获取并移除**
>
> - **poll()** 　获取并移除此队列的头，如果此队列为空，则返回 null
> - remove()　　获取并移除此队列的头，如果此队列为空，则抛出NoSuchElementException异常
>
> **2.获取但不移除**
>
> - **peek()**　　获取队列的头但不移除此队列的头。如果此队列为空，则返回 null
> - element()　　获取队列的头但不移除此队列的头。如果此队列为空，则将抛出NoSuchElementException异常
>
> **添加元素的方法**
>
> - **offer()**　　将指定的元素插入此队列（如果立即可行且不会违反容量限制），插入成功返回 true；否则返回 false。
> - add()　　将指定的元素插入此队列，add方法可能因为容量限制无法插入元素，会抛出一个 IllegalStateException异常







## 栈

（先进后出，只有一端可以进出）

### 继承关系

Stack来自于Vector，那么显然stack的底层实现是数组。

<img src="https://img-blog.csdnimg.cn/2019010523071981.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ltYmluZ29lcg==,size_16,color_FFFFFF,t_70" alt="stack继承关系" style="zoom:80%;" />

### 常用方法

1. java中Stack只有一个无参构造函数。

```java
Stack stack = new Stack();

//其他使用方法:使用数组或链表实现
Object[] stack = new Object[10];
```

2. 属于stack自己的方法包括

> - push( num) //入栈
> - pop() //栈顶元素出栈
> - empty() //判定栈是否为空
> - peek() //获取栈顶元素
> - search(num) //判端元素num是否在栈中，如果在返回1，不在返回-1

**注意pop()和peek()的区别。pop()会弹出栈顶元素并返回栈顶的值，peek()只是获取栈顶的值，但是并不会把元素从栈顶弹出来。**





# 排序方法（十大）

选择排序

​	简答选择排序：选择最小的元素放在队列最左边

​	堆排序：构建大根堆，取出根节点，然后继续构建根节点

插入排序

​	简单插入排序：从第二位开始遍历，插入到前面排序好的序列

​	希尔排序：简单插入排序的优化，将序列分为若干组，同一列进行插入排序，逐渐减少组的个数直到只有一个组

交换排序

​	冒泡排序：相邻两个元素交换，大的放在后面，一趟遍历后最大的在最后面

​	快速排序：选第一个元素作为基准，比它小的放左边，比它大的放右边

归并排序：分解数组后逐步合并

计数排序及优化

​	计数排序：已知数的范围，根据数的大小放入到根据范围生成的数组中，最后将数组中的元素从左到右遍历出来

​	桶排序排序：将所有数据映射到不同的桶中，对桶内元素进行排序	

​	基数排序：低位排序到高位排序



# 查找方法（七大）

有序查找

​	二分查找：取中值，比它大在右边找，比它小在左边找【 `mid = (left + right)/2`】

​	插值查找（二分的优化）：【`mid = low + (high - low) * (key - arr[low]) / (arr[high] - arr[low])`】

​	斐波那契查找（二分的优化）：先根据斐波那契数列对数列进行补充，然后根据斐波那契确定中心点进行比较

无序查找

​	顺序查找：从头到尾比较

​	分块查找：要求块间有序，块内无序。在块内调用其他查找方法

​	哈希查找：先创建hash表，然后进行查找

​	树表查找：构建查找树进行查找。常见查找树：二叉查找树、平衡二叉查找树、红黑树、b树



# 树

**平衡树**（BT：Balance Tree）

要求任意节点的子树高度差小于等于1。

**二叉排序树**（BST：Binary Search Tree）

要求左孩子<根节点<右孩子。

**二叉平衡排序树**（AVL：）

在二叉排序的基础上，要求任意节点的子树高度差小于等于1。特点：

1. 非叶子节点最多拥有两个子节点
2. 非叶子节值大于左边子节点、小于右边子节点
3. 树的左右两边的层级数相差不会大于1
4. 没有值相等重复的节点

**红黑树**（Red-Black Tree）

红黑树是节点带有颜色属性的二叉排序树。二叉平衡搜索树的变体，但是它的左右子树高差有可能大于 1。要求：

- 性质1. 节点是红色或黑色。
- 性质2. 根节点是黑色。
- 性质3. 所有叶子都是黑色。（叶子是NULL节点）
- 性质4. 每个红色节点的两个子节点都是黑色。（从每个叶子到根的所有路径上不能有两个连续的红色节点）
- 性质5. 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。 

性质: 从根到叶子的最长的可能路径不多于最短的可能路径的两倍长。结果是这个树大致上是平衡的。

**B树**（Balance Tree）

B树是平衡的排序多叉树。一棵m阶B树是一棵平衡的m路搜索树，要求：

1. B树中所有节点的孩子节点数中的最大值称为B树的阶，记为M（**重点**）
2. 树中的每个节点至多有M棵子树，即：如果定了M，则这个B树中任何节点的子节点数量都不能超过M
3. 若根节点不是终端节点，则至少有两棵子树
4. 除根节点和叶节点外，所有点至少有m/2棵子树（上溢）
5. 所有的叶子结点都位于同一层。

<img src="https://upload-images.jianshu.io/upload_images/7862980-9f37abf83ae7a973.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp" alt="B树案例" style="zoom: 33%;" />



特性：

1. 关键字集合分布在整颗树中；

2. 任何一个关键字出现且只出现在一个结点中；

3. 搜索有可能在非叶子结点结束；

4. 其搜索性能等价于在关键字全集内做一次二分查找；

5. 自动层次控制；

**B树变体**

B+树：B树的变体，它与B树的差异在于：

- 有k个子结点的结点必然有k个关键码；
- 非叶结点仅具有索引作用，跟记录有关的信息均存放在叶结点中。
- 树的所有叶结点构成一个有序链表，可以按照关键码排序的次序遍历全部记录。

![B+树](https://files.cnblogs.com/yangecnu/Bplustreebuild.gif)



`B*`树：是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针；`B*`树定义了非叶子结点关键字个数至少为(2/3)*M，即块的最低使用率为2/3。

![B*树](https://img-blog.csdn.net/20160805192156312)















