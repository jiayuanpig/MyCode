# 排序算法

**时间复杂度：**O()

**空间复杂度：**O()



**思路：**



**代码**

```java

```





## 选择排序

**时间复杂度：**O(n^2)

**空间复杂度：**O(1)



**思路：**

1. **第一个跟后面的所有数相比，**如果小于（或小于）第一个数的时候，暂存较小数的下标，第一趟结束后，将第一个数，与暂存的那个最小数进行交换，第一个数就是最小（或最大的数）

2. 下标移到第二位，第二个数跟后面的所有数相比，一趟下来，确定第二小（或第二大）的数

3. 重复以上步骤

4. 直到指针移到倒数第二位，确定倒数第二小（或倒数第二大）的数，那么最后一位也就确定了，排序完成。



**代码**

```java
static public void selectSort(int[] nums) {
        for (int i = 0; i < nums.length; i++) {
            int index = i;
            for (int j = i + 1; j < nums.length; j++) {
                if(nums[j] < nums[index]){
                    index = j;
                }
            }
            if(index != i){
                int n = nums[i];
                nums[i] = nums[index];
                nums[index] = n;
            }
        }

    }
```



## 冒泡排序

**时间复杂度：**O(n^2)

**空间复杂度：**O(1)



**思路：**

1. **相邻两个数两两相比**，n[j]跟n[j+1]比，如果n[j]>n[j+1]，则将两个数进行交换，

2. j++, 重复以上步骤，第一趟结束后，最大数就会被确定在最后一位，这就是冒泡排序又称大（小）数沉底，

3. i++,重复以上步骤，直到i=n-1结束，排序完成。



**代码**

```java
static public void bubbleSort(int[] nums) {
        //冒泡排序，相邻两个数比较，大的放后面
        for (int i = 0; i < nums.length; i++) {
            for (int j = 0; j < nums.length - i - 1; j++) {
                if(nums[j]>nums[j+1]){
                    int n = nums[j];
                    nums[j] = nums[j+1];
                    nums[j+1] = n;
                }
            }
        }

    }
```



## 插入排序

**时间复杂度：**O(n^2)

**空间复杂度：**O(1)



**思路：**从第2个数开始，插入到前面合适的位置

**1.** 从第二位开始遍历，

**2.** 当前数（第一趟是第二位数）**与前面的数依次比较，如果前面的数大于当前数，则将前面的这个数放在当前数的位置上，当前数的下标-1**

**3. 重复以上步骤，直到当前数不大于前面的某一个数为止，这时，将当前数，放到这个位置，**

　　1-3步就是保证当前数的前面的数都是有序的，内层循环的目的就是将当前数插入到前面的有序序列里

**4.** 重复以上3步，直到遍历到最后一位数，并将最后一位数插入到合适的位置，插入排序结束。



**代码**

```java
static public void insertSort(int[] nums) {
        for (int i = 1; i < nums.length; i++) {
            int n = nums[i];
            for (int j = i - 1; j >= 0; j--) {
                if (n >= nums[j]) {
                    nums[j + 1] = n;
                    break;
                } else {
                    nums[j + 1] = nums[j];
                }
            }

        }

    }
```



## 快速排序

**时间复杂度：**O(nlogn)

**空间复杂度：**O(logn)



**思路：**递归

1. 选一个数作为基数（这里我选的是第一个数），大于这个基数的放到右边，小于这个基数的放到左边，等于这个基数的数可以放到左边或右边。

2. 一趟结束后，将基数放到中间分隔的位置，第二趟将数组从基数的位置分成两半，分割后的两个的数组继续重复以上步骤，选基数，将小数放在基数左边，将大数放到基数的右边，再分割数组，，，直到数组不能再分为止，排序结束。

3. 指针实现

   第一趟，第一个数为基数temp，设置两个指针left = 0，right = n.length-1，

   ①从right开始与基数temp比较，如果n[right]>=基数temp，则right指针向前移一位，继续与基数temp比较，直到不满足n[right]>基数temp

   ②从left开始与基数temp比较，如果n[left]<=基数temp，则left指针向后移一位，继续与基数temp比较，直到不满足n[left]<=基数temp

   ③将left和right所在位置数进行交换

   ④**当left = right时，将所在位置的数和第一个数进行交换，完成此次排序**（该步骤为了处理right所在数小于temp）

   ⑤剩余部分排序重复①-④步

**代码**

注意：while (nums[right] >= temp **&& left < right**)

```java
static public void quickSort(int[] nums, int start, int end) {
        //只有一个数据时
        if (start >= end) {
            return;
        }
        //保留初始坐标
        int left = start;
        int right = end;
        int temp = nums[left];//设置中间值为left
        //指针移动
        while (left < right) {
            while (nums[right] >= temp && left < right) {
                right--;
            }
            while (nums[left] <= temp && left < right) {
                left++;
            }

            if (left < right) {
                int n = nums[left];
                nums[left] = nums[right];
                nums[right] = n;
            }
        }
        //最后将基准为与i和j相等位置的数字交换!!!
        nums[start] = nums[left];
        nums[left] = temp;

        quickSort(nums, start, left - 1);
        quickSort(nums, left + 1, end);

    }
```



## 归并排序

**时间复杂度：**O()

**空间复杂度：**O()



**思路：**



**代码**

```java

```







## 基数排序

**时间复杂度：**O()

**空间复杂度：**O()



**思路：**



**代码**

```java

```





## 希尔排序

**时间复杂度：**O()

**空间复杂度：**O()



**思路：**



**代码**

```java

```







## 堆排序

**时间复杂度：**O()

**空间复杂度：**O()



**思路：**



**代码**

```java

```























