# 排序算法

**时间复杂度：**O()

**空间复杂度：**O()



**思路：**



**代码**

```java

```





## 选择排序

**时间复杂度：**O(n^2)

**空间复杂度：**O(1)



**思路：**

1. **第一个跟后面的所有数相比，**如果小于（或小于）第一个数的时候，暂存较小数的下标，第一趟结束后，将第一个数，与暂存的那个最小数进行交换，第一个数就是最小（或最大的数）

2. 下标移到第二位，第二个数跟后面的所有数相比，一趟下来，确定第二小（或第二大）的数

3. 重复以上步骤

4. 直到指针移到倒数第二位，确定倒数第二小（或倒数第二大）的数，那么最后一位也就确定了，排序完成。



**代码**

```java
static public void selectSort(int[] nums) {
        for (int i = 0; i < nums.length; i++) {
            int index = i;
            for (int j = i + 1; j < nums.length; j++) {
                if(nums[j] < nums[index]){
                    index = j;
                }
            }
            if(index != i){
                int n = nums[i];
                nums[i] = nums[index];
                nums[index] = n;
            }
        }

    }
```



## 冒泡排序

**时间复杂度：**O(n^2)

**空间复杂度：**O(1)



**思路：**

1. **相邻两个数两两相比**，n[j]跟n[j+1]比，如果n[j]>n[j+1]，则将两个数进行交换，

2. j++, 重复以上步骤，第一趟结束后，最大数就会被确定在最后一位，这就是冒泡排序又称大（小）数沉底，

3. i++,重复以上步骤，直到i=n-1结束，排序完成。



**代码**

```java
static public void bubbleSort(int[] nums) {
        //冒泡排序，相邻两个数比较，大的放后面
        for (int i = 0; i < nums.length; i++) {
            for (int j = 0; j < nums.length - i - 1; j++) {
                if(nums[j]>nums[j+1]){
                    int n = nums[j];
                    nums[j] = nums[j+1];
                    nums[j+1] = n;
                }
            }
        }

    }
```



## 插入排序

**时间复杂度：**O(n^2)

**空间复杂度：**O(1)



**思路：**从第2个数开始，插入到前面合适的位置

**1.** 从第二位开始遍历，

**2.** 当前数（第一趟是第二位数）**与前面的数依次比较，如果前面的数大于当前数，则将前面的这个数放在当前数的位置上，当前数的下标-1**

**3. 重复以上步骤，直到当前数不大于前面的某一个数为止，这时，将当前数，放到这个位置，**

　　1-3步就是保证当前数的前面的数都是有序的，内层循环的目的就是将当前数插入到前面的有序序列里

**4.** 重复以上3步，直到遍历到最后一位数，并将最后一位数插入到合适的位置，插入排序结束。



**代码**

```java
static public void insertSort(int[] nums) {
        //插入排序
        for (int i = 1; i < nums.length; i++) {
            for (int j = i; j > 0; j--) {
                if (nums[j-1] > nums[j]) {
                    int n = nums[j-1];
                    nums[j - 1] = nums[j];
                    nums[j] = n;
                }
            }
        }
    }
```



```java
static public void insertSort(int[] nums) {
        //插入排序2
        for (int i = 1; i < nums.length; i++) {
            int index = nums[i];
            for (int j = i; j > 0; j--) {
                if(nums[j-1] > index){
                    nums[j] = nums[j - 1];

                    if(j==1){
                        nums[j-1] = index;
                    }
                }else{
                    nums[j] = index;
                    break;
                }
            }

        }

    }
```



```java
static public void insertSort(int[] nums) {
        //插入排序2.2
        for (int i = 1; i < nums.length; i++) {
            int index = nums[i];
            int j;
            for(j=i;j>0&&nums[j-1]>index;j--){
                nums[j] = nums[j-1];
            }
            nums[j] =index;
        }
    }
```



## 快速排序

**时间复杂度：**O(nlogn)

**空间复杂度：**O(logn)



**思路：**递归

1. 选一个数作为基数（这里我选的是第一个数），大于这个基数的放到右边，小于这个基数的放到左边，等于这个基数的数可以放到左边或右边。

2. 一趟结束后，将基数放到中间分隔的位置，第二趟将数组从基数的位置分成两半，分割后的两个的数组继续重复以上步骤，选基数，将小数放在基数左边，将大数放到基数的右边，再分割数组，，，直到数组不能再分为止，排序结束。

3. 指针实现

   第一趟，第一个数为基数temp，设置两个指针left = 0，right = n.length-1，

   ①从right开始与基数temp比较，如果n[right]>=基数temp，则right指针向前移一位，继续与基数temp比较，直到不满足n[right]>基数temp

   ②从left开始与基数temp比较，如果n[left]<=基数temp，则left指针向后移一位，继续与基数temp比较，直到不满足n[left]<=基数temp

   ③将left和right所在位置数进行交换

   ④**当left = right时，将所在位置的数和第一个数进行交换，完成此次排序**（该步骤为了处理right所在数小于temp）

   ⑤剩余部分排序重复①-④步

**代码**

注意：while (nums[right] >= temp **&& left < right**) 而且一定要先从右边走，确保left和right的最终值小于等于temp

```java
static public void quickSort(int[] nums, int start, int end) {
        //只有一个数据时
        if (start >= end) {
            return;
        }
        //保留初始坐标
        int left = start;
        int right = end;
        int temp = nums[left];//设置中间值为left
        //指针移动
        while (left < right) {
            //注意：一定要先从右边走
            while (nums[right] >= temp && left < right) {
                right--;
            }
            while (nums[left] <= temp && left < right) {
                left++;
            }

            if (left < right) {
                int n = nums[left];
                nums[left] = nums[right];
                nums[right] = n;
            }
        }
        //最后将基准为与i和j相等位置的数字交换!!!
        nums[start] = nums[left];
        nums[left] = temp;

        quickSort(nums, start, left - 1);
        quickSort(nums, left + 1, end);

    }
```



## 归并排序

**时间复杂度：**O()

**空间复杂度：**O()



**思路：**

归并排序的思想就是先递归分解数组，再合并数组。

将数组分解最小之后，然后合并两个有序数组，基本思路是比较两个数组的最前面的数，谁小就先取谁，取了后相应的指针就往后移一位。然后再比较，直至一个数组为空，最后把另一个数组的剩余部分复制过来即可。



分而治之(divide - conquer);每个递归过程涉及三个步骤
第一, 分解: 把待排序的 n 个元素的序列分解成两个子序列, 每个子序列包括 n/2 个元素
第二, 治理: 对每个子序列分别调用归并排序MergeSort, 进行递归操作
第三, 合并: 合并两个排好序的子序列,生成排序结果

**代码**

```java
public class Solution {

    public static void main(String[] args) {
        int[] nums = {1, 2, 2, 3, 4, 1, 7, 4, 9, 11};
        int[] temp = new int[nums.length];
        mergeSort(nums,0,nums.length-1,temp);
        System.out.println(Arrays.toString(nums));
    }

    public static void mergeSort(int[] arr, int low, int high, int[] tmp) {
        if (low < high) {
            int mid = (low + high) / 2;
            mergeSort(arr, low, mid, tmp); //对左边序列进行归并排序
            mergeSort(arr, mid + 1, high, tmp);  //对右边序列进行归并排序
            merge(arr, low, mid, high, tmp);    //合并两个有序序列
        }
    }

    public static void merge(int[] arr, int low, int mid, int high, int[] tmp) {
        int i = 0;
        int j = low, k = mid + 1;  //左边序列和右边序列起始索引
        while (j <= mid && k <= high) {
            if (arr[j] < arr[k]) {
                tmp[i++] = arr[j++];
            } else {
                tmp[i++] = arr[k++];
            }
        }
        //若左边序列还有剩余，则将其全部拷贝进tmp[]中
        while (j <= mid) {
            tmp[i++] = arr[j++];
        }
        //若右边序列还有剩余，则将其全部拷贝进tmp[]中
        while (k <= high) {
            tmp[i++] = arr[k++];
        }

        for (int t = 0; t < i; t++) {
            arr[low + t] = tmp[t];
        }
    }


}
```







## 基数排序

**时间复杂度：**O()

**空间复杂度：**O()



**思路：**



**代码**

```java

```





## 希尔排序

**时间复杂度：**O()

**空间复杂度：**O()



**思路：**



**代码**

```java

```







## 堆排序

**时间复杂度：**O()

**空间复杂度：**O()



**思路：**



**代码**

```java

```























