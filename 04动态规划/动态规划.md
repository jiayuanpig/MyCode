# 动态规划



## 案例：斐波那契数列改进

```java
public class Solution {
    public static void main(String[] args) {
        
        System.out.println(fibo(10));
        System.out.println(fibo2(10));

        ArrayList<Integer> memory = new ArrayList<>();
        System.out.println(fibo3(10, memory));
        
        ArrayList<Integer> memory2 = new ArrayList<>();
        System.out.println(fibo4(10, memory2));

    }

    //递归
    static public int fibo(int n) {
        if (n == 0 || n == 1) {
            return n;
        }
        return fibo(n - 1) + fibo(n - 2);
    }

    //非递归
    static public int fibo2(int n) {
        if (n == 0 || n == 1) {
            return n;
        }
        int pre = 0;
        int next = 1;
        for (int i = 2; i <= n; i++) {
            int temp = next;
            next += pre;
            pre = temp;
        }
        return next;
    }

    //递归优化，自顶向下记忆化搜索
    //初次使用时传入空列表保存记录
    static public int fibo3(int n, ArrayList<Integer> memory) {
        if (memory.size() == 0) {
            memory.add(0);
            memory.add(1);
        }

        if (n <= memory.size() - 1) {
            return memory.get(n);
        } else {
            memory.add(fibo3(n - 1, memory) + fibo3(n - 2, memory));
        }
        return memory.get(n);
    }

    //动态规划，自底向上
    static public int fibo4(int n, ArrayList<Integer> memory) {
        if (memory.size() == 0) {
            memory.add(0);
            memory.add(1);
        }
        if (n <= memory.size() - 1) {//如果表中有记录，直接输出
            return memory.get(n);
        }
        for (int i = 2; i <= n ; i++) {//自底向上添加子问题解
            memory.add(fibo4(i - 1, memory) + fibo4(i - 2, memory));
        }
        return memory.get(n);//补充到需要的记录然后输出
    }

}
```



## 动态规划原理

**大部分动态规划都是一个递归的问题，而一般递归采用自上而下的思想，而动态规划使用自下而上的思想**

**百科定义：**动态规划将问题分解为若干子问题，同时保存子问题的答案，使得每个子问题只求解一次，最终获得原问题的答案。



递归问题都是解决重叠子问题的过程（难点是找到最优子结构），主要分为两种思路：

- 记忆化搜索（自顶向下解决问题）
- 动态规划（自底向上解决问题）

我们学习编程，习惯了自顶向下求解问题（递归），在自顶向下求解问题的过程中，发现了重复子问题，我们再加上缓存。而「动态规划」告诉我们，其实有一类问题我们可以从一个最简单的情况开始考虑，通过逐步递推，每一步都记住当前问题的答案，得到最终问题的答案，即「动态规划」告诉了我们「自底向上」思考问题的思路。

也就是说「动态规划」告诉我们的新的思路是：不是直接针对问题求解，由于我们找到了这个问题最开始的样子，因此后面在求解的过程中，每一步都可以参考之前的结果（在处理最优化问题的时候，叫「最优子结构」），由于之前的结果有重复计算（「重复子问题」），因此必须记录下来。

这种感觉不同于「记忆化递归」，「记忆化递归」是直接面对问题求解，遇到一个问题解决了以后，就记下来，随时可能面对新问题。而「动态规划」由于我们发现了这个问题「最初」的样子，因此每一步参考的以前的结果都是知道的，就像我们去考试，所有的考题我们都见过，并且已经计算出了答案一样，我们只需要参考以前做题的答案，就能得到这一题的答案，这是「状态转移」。应用「最优子结构」是同一回事，即：综合以前计算的结果，直接得到当前的最优值。



**动态规划的步骤：**

**1、设计状态变量**

对于状态变量的设计可以采取一维状态变量`dp[i]`和二维状态变量`dp[i][0],dp[i][1]`。一维状态变量需要考虑**后效性问题**。二维状态变量相对于一维状态变量通过增加维度来消除后效性。

例如：一维状态变量`dp[i]`表示区间 `[0，i]` 里接受预约请求的最大时长；而二维状态变量则表示了在`i`处的状态：

- `dp[i][0]`：区间 [0, i] 里接受预约请求，并且下标为 i 的这一天不接受预约的最大时长
- `dp[i][1]`：区间 [0, i] 里接受预约请求，并且下标为 i 的这一天接受预约的最大时长**

**无后效性的理解**：1、后面的决策不会影响到前面的决策； 2、之前的状态怎么来的并不重要。

**2、确定状态转移方程**

**3、初始化变量**

**4、考虑输出**

**5、考虑是否可状态压缩**



![「动态规划」问题思考方向.png](https://pic.leetcode-cn.com/1f95da43d1bdeebdd1213bb804034ddc5f906dc61451cd63f2b5ab5d0eb33b33-%E3%80%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E3%80%8D%E9%97%AE%E9%A2%98%E6%80%9D%E8%80%83%E6%96%B9%E5%90%91.png)









## 动态规划典型案例

### 爬楼梯问题（70）

要求：一个楼梯，总共n个台阶，每次上一个或两个台阶。问，爬上这个楼梯一共多少种方法？



思路：斐波那契数列的动态规划解法



### 最小路径问题

#### 最小路径和（64）

要求：给定一个包含非负整数的 *m* x *n* 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。【每次只能向下或者向右移动一步。】

示例：

```
输入:
[
  [1,3,1],
  [1,5,1],
  [4,2,1]
]
输出: 7
解释: 因为路径 1→3→1→1→1 的总和最小。
```





#### 三角形最小路径和（120）

要求：给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。【相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。】

示例：

```
[
     [2],
    [3,4],
   [6,5,7],
  [4,1,8,3]
]
自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。
```



#### 不同路径（62）

要求：一个机器人位于一个 m x n 网格的左上角 。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角。问总共有多少条不同的路径？

示例：

 ```
 输入: m = 3, n = 2
 输出: 3
 解释:
 从左上角开始，总共有 3 条路径可以到达右下角。
     1. 向右 -> 向右 -> 向下
     2. 向右 -> 向下 -> 向右
     3. 向下 -> 向右 -> 向右
 ```



#### 不同路径2（63）

一个机器人位于一个 m x n 网格的左上角 。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角。现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？

 ```
 输入:
 [
 	[0,0,0],
 	[0,1,0],
 	[0,0,0]
 ]
 输出: 2
 解释:
 	3x3 网格的正中间有一个障碍物。
 	从左上角到右下角一共有 2 条不同的路径：
 	1. 向右 -> 向右 -> 向下 -> 向下
 	2. 向下 -> 向下 -> 向右 -> 向右
 ```







### 数的分解

#### 整数拆分（343）

要求：给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。【你可以假设 *n* 不小于 2 且不大于 58。】

示例 ：

```
输入: 10
输出: 36
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。
```

思路：假设数为n，第一步将其分割为1+(n-1)、2+(n-2)、...、(n-1)+1，第二步再将第二个数n-1、n-2、...、1进行分割。就将其转化为子问题进行求解。



#### 完全平方数（279）

要求：给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。


示例 :

```
输入: n = 13
输出: 2
解释: 13 = 4 + 9。
```



### 解码方法（91）

要求：一条包含字母 A-Z 的消息通过以下方式进行了编码：

> 'A' -> 1
> 'B' -> 2
> ...
> 'Z' -> 26

​	给定一个只包含数字的非空字符串，请计算解码方法的总数。

示例：

```
示例 1:
输入: "12"
输出: 2
解释: 它可以解码为 "AB"（1 2）或者 "L"（12）。

示例 2:
输入: "226"
输出: 3
解释: 它可以解码为 "BZ" (2 26), "VF" (22 6), 或者 "BBF" (2 2 6) 。
```



### 小偷问题

#### 打家劫舍（198）

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。



```
示例 1：

输入：[1,2,3,1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。
示例 2：

输入：[2,7,9,3,1]
输出：12
解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
     偷窃到的最高金额 = 2 + 9 + 1 = 12 。
```



思路：偷取房子范围为【0~n-1】，第一步确定偷取第一所房子的位置0，1，...，n-1，第二步考虑根据第一步偷第二所不连续的房子，例如0-->2,...,n-1，1-->3,...,n-1。



<!--（彩蛋：看一下该问题的评论区）-->



#### 打家劫舍2（213）

环形版

#### 打家劫舍3（337）

二叉树版



### 股票买卖（309）







### 背包问题

参考：https://blog.bill.moe/DP-backpack-notes/

#### 0-1背包问题

有n种物品，每个物品有两个属性：代价与价值。每种物品只能选一个，给定一个载代价为m的背包，求可以获得的价值最大值。



三步优化：二维数组--》两行数组--》一行数组











#### 完全背包问题

有n种物品，每个物品有两个属性：代价与价值。每种物品只能选可以选无限个，给定一个载代价为m的背包，求可以获得的价值最大值。



#### 多维背包问题

多维背包对于每一个物品有多种付出的代价（如：重量，体积同时限制），仍然要求价值最大。



#### 多重背包

有n种物品，每个物品有三个属性：代价，价值与可选次数。给定一个载代价为m的背包，求可以获得的价值最大值。



#### 树上背包

树上有一些物品，对这一些物品做0-1/完全/多重背包，满足所选点形成一个连通块。

### 

